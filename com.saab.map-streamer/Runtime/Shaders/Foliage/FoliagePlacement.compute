/* 
 * Copyright (C) SAAB AB
 *
 * All rights, including the copyright, to the computer program(s) 
 * herein belong to Saab AB. The program(s) may be used and/or
 * copied only with the written permission of Saab AB, or in
 * accordance with the terms and conditions stipulated in the
 * agreement/contract under which the program(s) have been
 * supplied. 
 * 
 * Information Class:          COMPANY RESTRICTED
 * Defence Secrecy:            UNCLASSIFIED
 * Export Control:             NOT EXPORT CONTROLLED
 */

#pragma kernel CSPlacement
#pragma kernel CSSurfaceHeightMap
#pragma kernel CSHeightMap
#pragma kernel CSCull
#pragma kernel CSPreCull
#pragma kernel CSPostCull
#pragma kernel CSFindBufferSize
#pragma kernel CSFindMinUv
#pragma kernel CSFindMinMax
//#pragma kernel CSDownscaleDepth
#pragma kernel CSClear

#include "UnityCG.cginc"

struct FoliagePoint
{
    float3 Position;
    float3 Color;
    float Height;
    float Random;
    float Visibility;
};

struct FoliageShaderData
{
    float2 MaxMin;
    float2 Offset;
    float Weight;
};

// mesh buffers

#define PI 3.14159265358979323846264338327950
#define RAD2DEG 57.2957795
#define DEG2RAD 0.01745329251994329576923690768489

StructuredBuffer<float> VertexBuffer; // Adjust data types based on your mesh format
ByteAddressBuffer IndexBuffer;
uint PositionOffset;
uint TexcoordOffset;
uint VertexBufferStride;


RWStructuredBuffer<uint> BufferSize;
RWStructuredBuffer<uint> MinXY;

StructuredBuffer<bool> FeatureMap; // feature map => int[255] 

AppendStructuredBuffer<FoliagePoint> TerrainPoints;     // Calculated points for one mesh
RWStructuredBuffer<FoliagePoint> InputBuffer;           // buffer with all points
StructuredBuffer<float> PixelToWorld;                   // matrix pixel to world (worldpixel coord)VertexBuffer
AppendStructuredBuffer<FoliagePoint> OutputBuffer;      // buffer with all (frustum) culled points 

RWStructuredBuffer<uint> AngleDepth;

// textures input
Texture2D<unorm float> SplatMap;
Texture2D<float4> Texture;
Texture2D<unorm float> HeightSurface;
RWTexture2D<float> SurfaceHeightMap;
RWTexture2D<float> HeightMap;
Texture2D<float> DepthTexture;

uint DownscaleFactor;
Texture2D<float> DepthTextureLowRes;

int FrameCount;

// Camera
float2 Fov;
float3 CameraPosition; // camera position in worldPos
float4 frustumPlanes[6]; // Frustum planes (6 planes * 4 floats: [ normal.x, normal.y, normal.z, distance ])
uniform float4x4 WorldToScreen; // World to clipPos
float3 CameraRightVector; // The right vector of the camera
float3 CameraForwardVector; // The right vector of the camera

// Global Variables
float AngleResolutionScale;
uint BufferCount;
bool Occlusion;
uint Scale;
float2 DownscaleSize; // size of screen in pixels (for depthtexture)
float2 NodeOffset; // botom left corner of node in "world" space
float maxHeight; // max size of foliage in meters
uint indexCount; // mesh index count
uint uvCount; // the size of surfaceUVs buffer
float2 terrainResolution; // Resolution of texture/feauture texture
float2 heightResolution; // Resolution of height texture
float3 terrainSize; // size of terrain (mesh) size
float2 Resolution; // the size of each pixel in meters
float Density; // density of trees
float3 MeshBoundsMax; // Mesh offset
float4x4 ObjToWorld; // Local To World
float ScreenCoverage;

uint FoliageCount;
StructuredBuffer<FoliageShaderData> FoliageData;

// ************* Inside triangle check ************* //
bool InsideTriangle(float2 p, float2 A, float2 B, float2 C)
{
    float area = 0.5 * (-B.y * C.x + A.y * (-B.x + C.x) + A.x * (B.y - C.y) + B.x * C.y);
    float sign = area < 0 ? -1 : 1;

    float s = (A.y * C.x - A.x * C.y + (C.y - A.y) * p.x + (A.x - C.x) * p.y) * sign;
    float t = (A.x * B.y - A.y * B.x + (A.y - B.y) * p.x + (B.x - A.x) * p.y) * sign;

    return s >= 0 && t >= 0 && (s + t) <= 2 * area * sign;
}

// ************* Plane Intersect ************* //
float PlaneIntersect(float3 origin, float3 ray, float3 planeNormal, float3 planeCoord, out bool success)
{
    success = true;
    // calculate plane
    float distance = dot(planeNormal, planeCoord);

    // avoid divide by zero
    if (dot(planeNormal, ray) == 0)
    {
        success = false;
        return 0;
    }

    // Compute the t value for the directed line ray intersecting the plane
    float t = (distance - dot(planeNormal, origin)) / dot(planeNormal, ray);

    // scale the ray by t
    float3 newRay = ray * t;

    // calc contact point
    float3 contact = origin + newRay;

    return contact.y;
}

float GetHeightOfPlaneAtXZ(float3 planeNormal, float3 pointInPlane, float2 xz, out bool success)
{
    success = true;
    
    //Probably not necessary since terrain triangles should never be perfectly vertical.
    if (planeNormal.y == 0)
    {
        success = false;
        return 0;
    }
    
    float yByX = -planeNormal.x / planeNormal.y;
    float yByZ = -planeNormal.z / planeNormal.y;
    
    float diffX = xz.x - pointInPlane.x;
    float diffZ = xz.y - pointInPlane.z;
    
    return pointInPlane.y + diffX * yByX + diffZ * yByZ;
}

float3 GetPixelCoord(float2 uv, float height = 0)
{
    // z-coordinate is negative because of the infamous BTA Z-flip	
    float3 coord = float3(uv.x * Resolution.x + MeshBoundsMax.x, height, -uv.y * Resolution.y + MeshBoundsMax.z);
    return coord;
}

float Random(float input, float mutator = 0.546)
{
    float nonInteger = 43758.5453; // A different constant to avoid common factors with typical inputs
    float seed = input + mutator * nonInteger;
    return frac(sin(seed) * 12345.6789);
}

float Random2D(float2 input, float mutator = 0.546)
{
    float i = (input.x * 131.071) + (input.y * 655.37);
    return Random(i, mutator);
}

float BilinearHeight(int2 texCoord, float2 frac)
{
    float dl, dr, ul, ur;

    dl = HeightMap[texCoord].r;
    dr = HeightMap[int2(texCoord.x + 1, texCoord.y)].r;
    ul = HeightMap[int2(texCoord.x, texCoord.y + 1)].r;
    ur = HeightMap[int2(texCoord.x + 1, texCoord.y + 1)].r;

    float dx = lerp(dl, dr, frac.x);
    float ux = lerp(ul, ur, frac.x);

    return lerp(ux, dx, frac.y);
}

float2 GetWorldCoord(uint2 texCoord, float3x3 worldToTexCoord, float2 nodeCoord)
{
    float stepsize = 1 / Density;
    float3 worldCoord = mul(worldToTexCoord, float3(texCoord.xy, 1));

    float2 nodeOffset = worldCoord / stepsize;

    float wpx = ceil(nodeOffset.x) * stepsize;
    float wpy = ceil(nodeOffset.y) * stepsize;

    float2 foliageOffset = float2(fmod((wpx - worldCoord.x - Resolution.x), stepsize), fmod((wpy - worldCoord.y - Resolution.y), stepsize));

    float2 WorldPixelCoord = nodeCoord + (texCoord * Resolution);
    return WorldPixelCoord + foliageOffset;
}

float2 MapUv(float2 uv, float2 size = float2(1, 1))
{
    float2 coord = uv;
    
#ifdef UNITY_HALF_TEXEL_OFFSET
        coord -= float2(0.5 / size.x, 0.5 / size.y);
#endif
            
#if UNITY_UV_STARTS_AT_TOP
        coord.y = 1.0 - (coord.y / size.y); // Flip the y-coordinate if UVs start at the top
#endif
    
    return coord;
}

float3 GetPosition(uint index)
{
    uint actualIndex = index * VertexBufferStride + PositionOffset;
    float x = VertexBuffer[actualIndex];
    float y = VertexBuffer[actualIndex + 1];
    float z = VertexBuffer[actualIndex + 2];
    
    return float3(x, y, z);
}

float2 GetTexCoord(uint index)
{
    uint actualIndex = index * VertexBufferStride + TexcoordOffset;
    float x = VertexBuffer[actualIndex];
    float y = VertexBuffer[actualIndex + 1];
    
    return float2(x, y);
}

// ************* Handle foliage Height ************* //

int WeightedRandomHeight(float random, float height)
{
    float weightSum = 0;
    for (int index = 0; index < FoliageCount; index++)
    {
        float heightWeight = FoliageData[index].MaxMin.x > height ? 0 : 1;
        weightSum += FoliageData[index].Weight * heightWeight;
    }

    float r = random * weightSum;

    for (int i = 0; i < FoliageCount; i++)
    {
        float heightWeight = FoliageData[i].MaxMin.x > height ? 0 : 1;
        r -= (FoliageData[i].Weight * heightWeight);
        if (r >= 0)
            continue;

        if (heightWeight == 0)
            return -1;

        return i;
    }
    return -1;
}

float GetFoliageHeight(FoliagePoint data, FoliageShaderData foliageData)
{
    float random = data.Random;
    float surfaceHeight = data.Height;

    float2 minMaxHeight = foliageData.MaxMin;
    float2 offset = foliageData.Offset;
    float weight = foliageData.Weight;

    // ********************* ***************  ********************* //
    float foliageHeight = minMaxHeight.x + ((minMaxHeight.y - minMaxHeight.x) * Random(random, 0.321f));
    foliageHeight = clamp(foliageHeight, minMaxHeight.x, surfaceHeight);
    return foliageHeight;
}

// ************* Find min uv value ************* //
[numthreads(32, 1, 1)]
void CSFindMinUv(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= uvCount)
        return;

    InterlockedMin(MinXY[0], (uint) (GetTexCoord(id.x).x * terrainResolution));
    InterlockedMin(MinXY[1], (uint) (GetTexCoord(id.x).y * terrainResolution));
}

[numthreads(8, 8, 1)]
void CSFindMinMax(uint3 id : SV_DispatchThreadID)
{
    float height = HeightSurface[id.xy] * 255;

    InterlockedMin(MinXY[0], (uint) (height));
    InterlockedMax(MinXY[1], (uint) (height));
}

// ************* Generate Placement ************* //
[numthreads(8, 8, 1)]
void CSFindBufferSize(uint3 id : SV_DispatchThreadID)
{
    uint feature = uint(SplatMap[id.xy] * 255.0);
    if (FeatureMap[feature])
    {
        InterlockedAdd(BufferSize[0], 1);
    }
}

// ************* surfaceHeight Map Gen ************* //
[numthreads(8, 8, 1)]
void CSSurfaceHeightMap(uint3 id : SV_DispatchThreadID)
{
    float3 color = Texture[id.xy];
    SurfaceHeightMap[id.xy] = 3 + length(color) / 3 * 18;
}

uint3 loadTriangleIndices(uint nTriangle)
{
    uint offsetBytes = nTriangle * 6;
    uint dwordAlignedOffset = offsetBytes & ~3;
    uint2 four16BitIndices = IndexBuffer.Load2(dwordAlignedOffset);
    uint3 indices;
    if (dwordAlignedOffset == offsetBytes)
    {
        indices.x = four16BitIndices.x & 0xffff;
        indices.y = (four16BitIndices.x >> 16) & 0xffff;
        indices.z = four16BitIndices.y & 0xffff;
    }
    else
    {
        indices.x = (four16BitIndices.x >> 16) & 0xffff;
        indices.y = four16BitIndices.y & 0xffff;
        indices.z = (four16BitIndices.y >> 16) & 0xffff;
    }
    return indices;
}

// ************* Height Map Gen ************* //
[numthreads(4, 4, 4)]
void CSHeightMap(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= indexCount)
    {
        return;
    }

    uint3 indexIndices = loadTriangleIndices(id.x);

    // Vertices for one triangle
    float3 v1 = GetPosition(indexIndices.x);
    float3 v2 = GetPosition(indexIndices.y);
    float3 v3 = GetPosition(indexIndices.z);

    float maxVert = max(max(v1.y, v2.y), v3.y);

    // pixelcoords for one triangle
    float2 uv1 = GetTexCoord(indexIndices.x) * terrainResolution;
    float2 uv2 = GetTexCoord(indexIndices.y) * terrainResolution;
    float2 uv3 = GetTexCoord(indexIndices.z) * terrainResolution;
    
    // triangle normal
    float3 planeNormal = normalize(cross(v2 - v1, v3 - v1));

    // pixel grid to work
    uint Xmax = max(max(uv1.x, uv2.x), uv3.x);
    uint Xmin = min(min(uv1.x, uv2.x), uv3.x);
    uint Ymax = max(max(uv1.y, uv2.y), uv3.y);
    uint Ymin = min(min(uv1.y, uv2.y), uv3.y);

    float height = maxVert;

    // divide the for loop in 4x4 threads
    // TODO: WHY + 2?!?!
    uint offsetX = ceil((Xmax - Xmin + 2) / 4);
    uint startX = Xmin + (id.y * offsetX);
    uint endX = Xmin + ((id.y + 1) * offsetX);
    endX = min(Xmax, endX);

    uint offsetY = ceil((Ymax - Ymin + 2) / 4);
    uint startY = Ymin + (id.z * offsetY);
    uint endY = Ymin + ((id.z + 1) * offsetY);
    endY = min(Ymax, endY);

    bool success = true;

    for (uint x = startX; x <= endX; x++)
    {
        for (uint y = startY; y <= endY; y++)
        {
            float2 uv = float2(x, y);

            if (InsideTriangle(uv, round(uv1), round(uv2), round(uv3)))
            {
                float3 pixelCoord = GetPixelCoord(uv, 1024);
                height = GetHeightOfPlaneAtXZ(planeNormal, v1, pixelCoord.xz, success);

                if (!success)
                    height = maxVert;

                HeightMap[uv] = height;
            }
        }
    }
}

// ************* Generate Placement ************* //
[numthreads(4, 4, 4)]
void CSPlacement(uint3 id : SV_DispatchThreadID)
{
    float3x3 ToWorldTexCoord =
    {
        PixelToWorld[0], PixelToWorld[1], PixelToWorld[2],
        PixelToWorld[3], PixelToWorld[4], PixelToWorld[5],
        PixelToWorld[6], PixelToWorld[7], PixelToWorld[8],
    };

    float stepsize = (1 / Density);
    uint xCount = ceil(max(Resolution.x * Density, Resolution.x));
    uint yCount = ceil(max(Resolution.y * Density, Resolution.y));

    float subPixelX = (1.0 / xCount);
    float subPixelY = (1.0 / yCount);
    float2 subPixel = float2(subPixelX, subPixelY);

    uint2 uv = id.xy;
    uint feature = uint(SplatMap[uv] * 255);
    float2 pixelOverLap = float2(2, 0);

    if (FeatureMap[feature])
    {
        // divide the for loop in 4 threads
        uint threadx = ceil(xCount / 4.0);
        uint start = id.z * threadx;
        uint end = start + threadx;
        end = min(end, xCount);

        // loop throgh all potential points in pixel
        for (uint x = start; x < end; x++)
        {
            for (uint y = 0; y < yCount; y++)
            {
                float2 pixelOffset = subPixel * float2(x, y);
                float3 worldCoord = mul(ToWorldTexCoord, float3(uv.xy + pixelOffset.xy, 1));

                float2 nodeOffset = worldCoord.xy / stepsize;
                float wpx = ceil(nodeOffset.x) * stepsize;
                float wpy = ceil(nodeOffset.y) * stepsize;

                float offsetX = (wpx - worldCoord.x);
                float offsetY = (wpy - worldCoord.y);

                float2 foliagePoint = float2(GetPixelCoord(uv + pixelOffset + pixelOverLap).x + offsetX, GetPixelCoord(uv + pixelOffset + pixelOverLap).z - offsetY); //- (Resolution.y - offsetY));

                float2 randoffset = fmod(GetWorldCoord(uv, ToWorldTexCoord, NodeOffset), 1000);
                float2 rand = randoffset * 0.001;
                rand += Random(rand.x + rand.y);

                float angle = (Random2D(rand, 3.731) * 2 - 1) * 3.141592;
                float2 randDir = float2(cos(angle), sin(angle));
                
                float distance = Random2D(rand, 12.243) * (stepsize * 0.5) * 1.5;
                float2 randomPoint = randDir * distance;
                float2 uvfrac = frac(randomPoint / Resolution);
                float2 uvOffset = floor(randomPoint / Resolution);
                uvOffset.y *= -1;

                // check if uv coord is valid (handle pixel Overlap)
                if (any((uv + uvOffset) > (terrainResolution - float2(2, 2))) || any((uv + uvOffset) < float2(1, 1)))
                    continue;

                feature = uint(SplatMap[uv + uvOffset] * 255);
                float height = BilinearHeight(uv + uvOffset, uvfrac);

                if (offsetX < (Resolution.x * subPixelX) && offsetY < (Resolution.y * subPixelY) && FeatureMap[feature])
                {
                    float3 color = Texture[uv + uvOffset].xyz;
                    float2 corrd = float2(clamp((uv + uvOffset).x - 1, 0, terrainResolution.x - 2), clamp((uv + uvOffset).y - 1, 0, terrainResolution.y - 2));

                    float2 uvHeight = (corrd / (terrainResolution.xy)) * heightResolution.xy;

                    float surfaceHeight = HeightSurface[uvHeight] * 255;

                    // Check if surfaceHeight is "Undefined" give random value as in CSSurfaceHeightMap
                    if (surfaceHeight <= 0)
                    {
                        surfaceHeight = (3 + length(color) / 3 * 18) * 255;
                    }
                                                    
                    float3 coord = float3(foliagePoint.x + randomPoint.x, height, foliagePoint.y + randomPoint.y);

                    FoliagePoint res;
                    res.Position = coord.xyz;
                    res.Color = color;
                    res.Random = Random2D(rand);
                    res.Height = surfaceHeight;
                    res.Visibility = 0;
                    
                    TerrainPoints.Append(res);
                }
            }
        }
    }
}

// ************* Terrain frustum culling ************* //
inline bool IsInFrustum(float3 positionAfterProjection, float threshold)
{
    return (dot(normalize(frustumPlanes[0].xyz), positionAfterProjection) >= threshold &&
        dot(normalize(frustumPlanes[1].xyz), positionAfterProjection) >= threshold &&
        dot(normalize(frustumPlanes[2].xyz), positionAfterProjection) >= threshold &&
        dot(normalize(frustumPlanes[3].xyz), positionAfterProjection) >= threshold);
}

float3 GetScreenPos(float3 pos)
{
    float4 clipCoord = mul(WorldToScreen, float4(pos.xyz, 1));
    float DepthPos = clipCoord.z;
    float2 screenPos = clipCoord.xy / clipCoord.w; // converts to a range (-1) - 1
    screenPos = screenPos * 0.5 + 0.5; // convert to a range 0- 1
    screenPos *= _ScreenParams.xy; // convert to pixel coordiantes
    
    // clamp screenPos to always be in screen
    screenPos.xy = clamp(screenPos.xy, float2(0, 0), _ScreenParams.xy - 1);
    
    return float3(screenPos.xy, DepthPos);
}

bool IsHidden(float3 worldPos, float height, float3 toFoliage)
{
    // Get projected screen-space positions
    float3 mid = GetScreenPos(worldPos + float3(0, height * 0.5, 0) - toFoliage * height);
    float3 topRight = GetScreenPos(worldPos + CameraRightVector * 0.5f * height * 0.2 + float3(0, height * 0.8, 0));
    float3 bottomLeft = GetScreenPos(worldPos - CameraRightVector * 0.5f * height * 0.2);
    
    float depth = mid.z - 0.01;
    
    int2 downscale = int2(DownscaleFactor, DownscaleFactor);
    int2 screenSize = int2(_ScreenParams.xy);
    int2 lowResSize = floor(screenSize / (float)downscale);
    
    int2 minXY = int2(floor(min(bottomLeft.xy, topRight.xy) / (float)downscale));
    int2 maxXY = int2(ceil(max(bottomLeft.xy, topRight.xy) / (float)downscale));
    
    // 1-pixel safety margin
    minXY -= 1;
    maxXY += 1;
    
    // Clamp to screen bounds
    minXY = clamp(minXY, int2(0, 0), lowResSize.xy - 1);
    maxXY = clamp(maxXY, int2(0, 0), lowResSize.xy - 1);
    
    for (int y = minXY.y; y < maxXY.y; y += 2)
    {
        int offset = y % 2;
        for (int x = minXY.x + offset; x < maxXY.x; x += 2)
        {
            int2 lowResPixel = int2(x, y);
            float sceneDepth = DepthTexture.Load(int3(lowResPixel, 0)); // point sampling
            
            // Early out if any pixel shows visible geometry
            if (sceneDepth > depth + 0.02f) // tweak based on scene scale
                return false; // visible
        }
    }
    
    return true;
}

float CalculateDesiredDistance(float vFov, float objectHeight, float coverage)
{
    float halfFov = vFov * 0.5 * DEG2RAD;
    
    return objectHeight / (2.0 * tan(halfFov) * coverage);
}

uint2 UnpackIndex(uint index, uint bufferWidth)
{
   
    // Recover pitchIndex and yawIndex from the single 'index'
    uint pitchIndex = index / bufferWidth;
    uint yawIndex = index % bufferWidth;
    
    return uint2(yawIndex, pitchIndex);
}

float2 IndexToAngle(uint index, float2 fov)
{
    // Use the same resolution and FOV parameters as in AngleIndex
    float resolutionScale = AngleResolutionScale;
    uint bufferWidth = (uint) (180.0 * resolutionScale);

    // Recover pitchIndex and yawIndex from the single 'index'
    uint pitchIndex = index / bufferWidth;
    uint yawIndex = index % bufferWidth;

    // Convert discrete indices back to normalized [0..1]
    float normalizedYaw = (float) yawIndex / (float) (bufferWidth - 1);
    float normalizedPitch = (float) pitchIndex / (float) (bufferWidth - 1);

    // Convert normalized [0..1] back to angles in degrees:
    //   0   -> -fov/2
    //   1   -> +fov/2
    float yawAngle = normalizedYaw * fov.x - (fov.x * 0.5);
    float pitchAngle = normalizedPitch * fov.y - (fov.y * 0.5);

    return float2(yawAngle, pitchAngle);
}

float2 GetAngle(float3 toPoint, float3 cameraForward, float3 cameraRight, float3 cameraUp, float2 fov, uint bufferWidth)
{
    // Normalize the direction vector
    float3 dir = normalize(toPoint);
   
    // Compute camera space coordinates
    // x: right, y: up, z: forward
    float x = dot(dir, cameraRight);
    float y = dot(dir, cameraUp);
    float z = dot(dir, cameraForward);
    
    if (z <= 0.001)
        z = 0;
    
    // Compute yaw and pitch in degrees.
    // atan2 returns the angle (in radians) between the z-axis and the projection onto the x-z or y-z plane.
    float yawAngle = degrees(atan2(x, z)); // horizontal angle
    float pitchAngle = degrees(asin(y));
           
    return float2(yawAngle, pitchAngle);
}

uint GetIndex(float2 yawPitch, uint bufferWidth, float2 fov)
{
    // Remap the angles from camera space to a normalized [0, 1] range.
    // The fov vector contains (horizontalFOV, verticalFOV)
    // Here, we assume the center of the view is 0 deg, with -fov/2 to +fov/2 covering the full fov.
    float normalizedYaw = saturate((yawPitch.x + (fov.x * 0.5)) / fov.x);
    float normalizedPitch = saturate((yawPitch.y + (fov.y * 0.5)) / fov.y);

    // Scale the normalized values into our discrete grid.
    // Multiplying by (bufferWidth - 1) ensures that bottom-left is index 0 and top-right is (bufferWidth - 1).
    uint yawIndex = (uint) (normalizedYaw * (bufferWidth - 1));
    uint pitchIndex = (uint) (normalizedPitch * (bufferWidth - 1));

    // Pack into a single index (row-major order):
    uint index = pitchIndex * bufferWidth + yawIndex;
    return index;
}

uint AngleIndex(float3 toPoint, float3 cameraForward, float3 cameraRight, float3 cameraUp, float2 fov, out float2 yawPitch)
{
    // resolutionScale is defined somewhere in your shader
    uint bufferWidth = (uint) (180.0 * AngleResolutionScale);
        
    // Compute yaw and pitch in degrees.
    yawPitch = GetAngle(toPoint, cameraForward, cameraRight, cameraUp, fov, bufferWidth);
    return GetIndex(yawPitch, bufferWidth, fov);
}

int GetRectangleWidth(uint minIndex, uint maxIndex, uint bufferWidth)
{
    int minX = minIndex % bufferWidth;
    int maxX = maxIndex % bufferWidth;
    
    return (maxX - minX);
}

void FillSkewedRectangleInterlockedMin(uint minIndex, uint maxIndex, float distance, float2 minYawPitch, float2 maxYawPitch, float tilt)
{
    uint bufferWidth = (uint) (180.0 * AngleResolutionScale);
    
    int rWidth = GetRectangleWidth(minIndex, maxIndex, bufferWidth);
    uint index = minIndex;
    uint rows = floor((float)(maxIndex - minIndex) / (float)bufferWidth);
    uint currentRow = 0;
    
    while (index < maxIndex)
    {
        uint rowStart = floor((float)index / (float)bufferWidth) * bufferWidth;
        uint rowEnd = ceil((float)index / (float)bufferWidth) * bufferWidth;
        int skew = (float)currentRow * tilt;
        
        int startIndex = index + skew;
        uint endIndex = startIndex + rWidth;
        
        for (uint x = max(rowStart, startIndex); x <= min(rowEnd, endIndex); x++)
        {
            InterlockedMin(AngleDepth[x], (uint) ceil(distance));
        }
        
        index += bufferWidth;
        currentRow++;
    }
}

void SetIndex(float3 toPoint, float3 forward, float3 right, float3 up, float distance)
{
    float2 YawPitch;
    uint index = AngleIndex(toPoint, forward, right, up, Fov, YawPitch);
    InterlockedMin(AngleDepth[index], (uint) ceil(distance));
}

bool PointInTriangle(float2 pt, float2 v0, float2 v1, float2 v2)
{
    // Barycentric technique
    float2 v0v1 = v1 - v0;
    float2 v0v2 = v2 - v0;
    float2 v0pt = pt - v0;

    float d00 = dot(v0v1, v0v1);
    float d01 = dot(v0v1, v0v2);
    float d11 = dot(v0v2, v0v2);
    float d20 = dot(v0pt, v0v1);
    float d21 = dot(v0pt, v0v2);
    float denom = d00 * d11 - d01 * d01;

    if (denom == 0.0f)
        return false;

    float u = (d11 * d20 - d01 * d21) / denom;
    float v = (d00 * d21 - d01 * d20) / denom;

    return (u >= 0) && (v >= 0) && (u + v <= 1);
}

void FillIndices(float3 bottomleft, float3 topRight, float3 bottomRight, float3 topLeft, float3 forward, float3 right, float3 up, float distance)
{
    const uint bufferWidth = (uint) (180.0 * AngleResolutionScale);
    const float2 halfFov = Fov * 0.5f;

    // Get yaw/pitch angles (in degrees)
    float2 bl = GetAngle(bottomleft, forward, right, up, Fov, bufferWidth);
    float2 br = GetAngle(bottomRight, forward, right, up, Fov, bufferWidth);
    float2 tl = GetAngle(topLeft, forward, right, up, Fov, bufferWidth);
    float2 tr = GetAngle(topRight, forward, right, up, Fov, bufferWidth);

    // Angle-space bounds
    float2 minAngle = min(min(bl, br), min(tl, tr));
    float2 maxAngle = max(max(bl, br), max(tl, tr));

    // Convert to index-space bounds (but don't round yet)
    float2 minNorm = saturate((minAngle + halfFov) / Fov);
    float2 maxNorm = saturate((maxAngle + halfFov) / Fov);

    uint2 minIdx = (uint2) (minNorm * (bufferWidth - 1));
    uint2 maxIdx = (uint2) (maxNorm * (bufferWidth - 1));

    for (uint py = minIdx.y; py <= maxIdx.y; py++)
    {
        for (uint px = minIdx.x; px <= maxIdx.x; px++)
        {
            // Convert back to yaw/pitch angle (center of pixel)
            float2 norm = float2(px + 0.5f, py + 0.5f) / (float) (bufferWidth - 1);
            float2 angle = norm * Fov - halfFov;

            // Point-in-triangle in angle space
            if (PointInTriangle(angle, bl, tl, tr) || PointInTriangle(angle, bl, tr, br))
            {
                uint index = py * bufferWidth + px;
                InterlockedMin(AngleDepth[index], (uint) ceil(distance));
            }
        }
    }
}

void SetIndices(float3 toBottomLeft, float3 toTopRight, float3 forward, float3 right, float3 up, float distance, float height = 0)
{
    float2 minYawPitch, maxYawPitch;
    uint minIndex = AngleIndex(toBottomLeft, forward, right, up, Fov, minYawPitch);
    uint maxIndex = AngleIndex(toTopRight, forward, right, up, Fov, maxYawPitch);
    
    FillSkewedRectangleInterlockedMin(minIndex, maxIndex, distance, minYawPitch, maxYawPitch, -0.5);
}

uint GetIndex(float3 toFoliage, float3 forward, float3 right, float3 up)
{
    float2 t1;
    return AngleIndex(toFoliage, forward, right, up, Fov, t1);
}

bool GetRandomizedData(FoliagePoint data, out FoliageShaderData output)
{
    float random = data.Random;
    float surfaceHeight = data.Height;
    
    int type = floor(random * FoliageCount);
    type = WeightedRandomHeight(random, surfaceHeight);
    if (type < 0)
        return false;
    
    output = FoliageData[type];
    return true;
}

bool HiddenCheck(uint depth, float distance, float height)
{
    return depth <= distance - (height * 0.5);
}

// ************* Cull Points ************* //
[numthreads(128, 1, 1)]
void CSCull(uint3 id : SV_DispatchThreadID)
{
    FoliagePoint data = InputBuffer[id.x]; 
            
    // handle points with no value. (allocated points in buffer is by default float3(0,0,0))
    if (dot(data.Position, data.Position) == 0)
        return;
    
    float3 forward = CameraForwardVector;
    float3 right = CameraRightVector;
    float3 up = normalize(cross(forward, right));
    
    FoliageShaderData foliageData = (FoliageShaderData)0;
    bool dataFound = GetRandomizedData(data, foliageData);
    
    if (!dataFound)
        return;
    
    float height = GetFoliageHeight(data, foliageData);
    
    if (height == 0)
        return;
    
    float3 worldUp = float3(0, 1, 0);
    float3 topPadding = worldUp * height * 0.1;
    float3 topOffset = worldUp * (height - foliageData.Offset.y * height) - topPadding;
    float3 pos = mul(ObjToWorld, float4(data.Position.xyz, 1)).xyz;
    
    
    float3 FoliageMid = pos + topOffset * 0.45;
    float3 FoliageTop = pos + topOffset * 0.85;
    float3 toFoliageMid = FoliageMid - CameraPosition;
    float3 toFoliageTop = FoliageTop - CameraPosition;
    
    float3 foliageRight = normalize(cross(up, FoliageMid)) * height * 0.5;
    
    float3 FoliageRight = FoliageMid + foliageRight * 0.02;
    float3 FoliageLeft = FoliageMid - foliageRight * 0.02;
    float3 toFoliageRight = FoliageRight - CameraPosition;
    float3 toFoliageLeft = FoliageLeft - CameraPosition;
    
    float distance = length(toFoliageMid);
    float desiredDistance = CalculateDesiredDistance(Fov.y/*This includes padding for shadows, but should maybe not*/, height, ScreenCoverage);
    
    if (desiredDistance < distance)
        return;
  
    // ****** falloff ******
    if (distance > desiredDistance * 0.50)
    {
        float seed = data.Random;
    
        float percentage = (distance - (desiredDistance * 0.50)) / (frustumPlanes[5].w * 0.5);
        if (percentage > seed)
            return;
    }

    if (IsInFrustum(toFoliageMid, -height))
    {
        if (FrameCount % 2 == id.x % 2)
        {   
            uint indexMid = GetIndex(toFoliageMid, forward, right, up);
            uint indexTop = GetIndex(toFoliageTop, forward, right, up);
            uint indexRight = GetIndex(toFoliageRight, forward, right, up);
            uint indexLeft = GetIndex(toFoliageLeft, forward, right, up);
            
            uint midDepth = AngleDepth[indexMid];
            uint topDepth = AngleDepth[indexTop];
            uint rightDepth = AngleDepth[indexRight];
            uint leftDepth = AngleDepth[indexLeft];
        
            bool midHidden = HiddenCheck(midDepth, distance, height);
            bool topHidden = HiddenCheck(topDepth, distance, height);
            bool rightHidden = HiddenCheck(rightDepth, distance, height);
            bool leftHidden = HiddenCheck(leftDepth, distance, height);
                                         
            if (midHidden && topHidden && rightHidden && leftHidden)
            {
                //return;
            }
             //******** occlussion culling ******** 
            else if (Occlusion && IsHidden(pos, height, normalize(toFoliageMid)))
            {
                //return;
            }
            else
            {
                if (data.Visibility <= 1)
                    data.Visibility += 0.25;
            }
        }
        
        if (data.Visibility <= 0)
            return;
        else
            data.Visibility -= 0.01;
        
        InputBuffer[id.x] = data;
        
        data.Position = pos;
        OutputBuffer.Append(data);
    }
}

[numthreads(256, 1, 1)]
void CSPostCull(uint3 id : SV_DispatchThreadID)
{
    int index = id.x;
    AngleDepth[index] = 0xffffffff;
}

[numthreads(128, 1, 1)]
void CSPreCull(uint3 id : SV_DispatchThreadID)
{
    FoliagePoint data = InputBuffer[id.x];
    
    // handle points with no value. (allocated points in buffer is by default float3(0,0,0)) 
    if (dot(data.Position, data.Position) == 0)
        return;
    
    float3 pos = mul(ObjToWorld, float4(data.Position.xyz, 1)).xyz;
    FoliageShaderData foliageData = (FoliageShaderData)0;
    bool dataFound = GetRandomizedData(data, foliageData);
    
    if (!dataFound)
        return;
    
    float height = GetFoliageHeight(data, foliageData);
    float halfheight = height * 0.5;
    
    //TODO: Skip this intermediate center-calculation and calculate corners directly?
    float3 centerOffset = float3(0, 0.5, 0) * height;
    float3 midPos = pos + centerOffset;
    float3 toFoliageMid = (midPos - CameraPosition);
    
    if (!IsInFrustum(toFoliageMid, -height))
        return;
    
    float distance = length(toFoliageMid);
    if (distance > frustumPlanes[5].w)
        return;
    
    float3 forward = CameraForwardVector;
    float3 right = CameraRightVector;
    float3 up = normalize(cross(forward, right));
   
    if (dot(toFoliageMid, forward) < 0) // Don't draw trees that are behind the camera.
        return;

    toFoliageMid = normalize(toFoliageMid);
    float3 worldUp = float3(0, 1, 0);
          
    float3 toFoliageRight = normalize(cross(up, toFoliageMid));

    float scale = 0.02;
    float3 topPadding = worldUp * height * 0.1;
    
    float3 rightOffset = toFoliageRight * height * 0.5 * scale;
    float3 topOffset = worldUp * (height - foliageData.Offset.y * height) - topPadding;
    
    float3 foliageBottomLeft = pos - rightOffset;
    float3 foliageTopRight = pos + rightOffset + topOffset;
    float3 foliageBottomRight = pos + rightOffset;
    float3 foliageTopLeft = pos - rightOffset + topOffset;
    
    float3 toFoliageBottomLeft = foliageBottomLeft - CameraPosition;
    float3 toFoliageTopRight = foliageTopRight - CameraPosition;
    float3 toFoliageBottomRight = foliageBottomRight - CameraPosition;
    float3 toFoliageTopLeft = foliageTopLeft - CameraPosition;
    
    FillIndices(toFoliageBottomLeft, toFoliageTopRight, toFoliageBottomRight, toFoliageTopLeft, forward, right, up, distance);
    //SetIndices(toFoliageBottomLeft, toFoliageTopRight, forward, right, up, distance, data.Height);
}

[numthreads(128, 1, 1)]
void CSClear(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= BufferCount)
        return;
    
    FoliagePoint res;
    res.Position = float3(0, 0, 0);
    res.Color = float3(0, 0, 0);
    res.Random = 0;
    res.Height = 0;
    res.Visibility = 0;
    
    TerrainPoints.Append(res);
}